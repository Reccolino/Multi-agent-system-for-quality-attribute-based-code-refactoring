task1:

    description: |
         You are MasterPrompt, a Security-Focused Static Code Analysis Expert. 
        Analyze the following Java source code:
        {code_class}
    
        Then generate a single, self-contained prompt in English that a downstream AI agent can use to:
    
        1. **Leverage SonarQube Quality Attributes**  
           - Examine Reliability, Security, Maintainability, Coverage, Code Smells and Duplications.  
           - Prioritize issues flagged by SonarQube Quality Gates (e.g., Security Rating, Vulnerabilities, Reliability Rating).
    
        2. **Integrate Java Static-Analysis Plugins**  
           - Instruct how to run Checkstyle rules for naming conventions and style consistency.  
           - Include PMD scans for bug patterns (unused variables, inefficient loops, null‐dereferences).  
           - Include FindBugs (SpotBugs) checks for bytecode-level security defects (e.g., null‐pointer dereference, SQL injection annotations).
    
        3. **Identify and Mitigate Critical/Blocker Vulnerabilities**  
           - Point out OWASP Top 10 risks: SQL injection, XSS, insecure deserialization, hardcoded credentials, weak cryptography.  
           - Detect use of insecure Java APIs (e.g., `Runtime.exec`, unsanitized JDBC statements, `ObjectInputStream` without validation).  
           - Highlight buffer overflow or memory‐unsafe patterns in native calls or array handling.
    
        4. **Suggest Concrete Remediation Steps**  
           - Propose secure coding best practices (input validation, prepared statements, safe deserialization).  
           - Recommend configuration changes or use of hardened libraries (e.g., use `java.sql.PreparedStatement`).  
           - Advise on writing test cases (unit/integration) to verify that vulnerabilities have been fixed.
    
        5. **Format and Output**  
           - The final output must be a single, clear prompt (in English) that can be provided verbatim to another AI model.  
           - Do not include code modifications yourself—only craft the instructions.  
           - Appendi **“###FINE”** esattamente alla fine del prompt per segnalare la conclusione.

    expected_output: |
      A single, self-contained English prompt that:
      - Clearly tells an AI agent how to run SonarQube and Java plugin scans (Checkstyle, PMD, FindBugs).  
      - Guides the AI to identify bad practices, code smells, style/logic inconsistencies, and critical security flaws (OWASP Top 10).  
      - Instructs the AI on remediation actions (secure APIs, input sanitization, configuration fixes, writing tests).  
      - Concludes with “###FINE” on its own line to stop further processing.

    agent: query_writer



task2:
    #ho notato che dando all'LLM comandi itemizzati, lui risponde meglio
    description: |
        You are MasterJava, a Java Code Refactoring Expert. 
        Using the prompt produced in task1 as guidance, refactor the given Java code according to these strict rules:
          1. **Preserve Structure:**  
             - Keep all class and method names exactly as originally defined, including constructors and overloads.  
             - Retain the original package declaration and all import statements.  
             - Do not change the order or number of methods, fields, or nested classes.
          2. **Maintain Comments & Licenses:**  
             - Keep every existing comment (single-line, multi-line, Javadoc) intact and in its original location.  
             - Preserve any license header if present. If no license is found in the original, do not add one.
          3. **Avoid Code Duplication:**  
             - Remove or consolidate duplicated code blocks by extracting common functionality into private helper methods or utility functions, without changing external behavior.
          4. **Retain Class Relationships:**  
             - Do not alter inheritance hierarchies, implemented interfaces, abstract class extensions, or annotations that affect class loading/behavior.
          5. **Minimize Changes:**  
             - Only refactor code that directly addresses issues highlighted in task1 (e.g., insecure APIs, code smells, bad practices).  
             - Do not introduce any new compilation or runtime errors.  
             - Do not add or remove test cases.
          6. **Maintain Functionality:**  
             - Ensure that for every refactored method or class, the original logic and behavior remain identical (input → output).  
             - Do not change method signatures, parameter lists, return types, or thrown exceptions.
          7. **Security & Best Practices:**  
             - Replace any usage of insecure Java APIs (e.g., raw `Runtime.exec`, unsanitized JDBC calls, unchecked deserialization) with secure alternatives (e.g., `ProcessBuilder`, `PreparedStatement`, validated serialization frameworks).  
             - Apply principle of least privilege: do not introduce new permissions or reduce security controls.
          8. **Formatting & Style:**  
             - Align formatting with common Java conventions (4-space indentation, consistent brace style) only if it does not conflict with existing project style.  
             - Do not remove or alter existing formatting in critical regions (e.g., aligned tables in comments, hand-tuned code alignment), unless necessary for security fixes.
          9. **Error Avoidance:**  
             - Guarantee no new syntax or compilation errors: compile the refactored code mentally to ensure correctness.  
             - Do not remove or alter try/catch blocks that handle critical exceptions, unless a safer alternative is provided.
         10. **Output Format:**  
             - Provide the fully refactored Java source, ready to compile without modification.  
             - Do not wrap the code in markdown fences; output the raw Java file content.  
             - Do not include any explanatory notes in the code; comments should exist only if they were in the original or are necessary for security context (e.g., “// Hardened to prevent SQL injection”).

    expected_output: >
        The complete refactored Java source code, preserving all original signatures, comments, licenses, and structure, with no compilation errors. The code must reflect improvements as instructed in the prompt from task1.

    context:
        - task1
    agent: code_refactor




task3:
    description: >
            Fai code replace in: {path_class} del codice refattorizzato dalla task precedente.

    expected_output: >
            Se il code replace è andato a buon fine
    context:
      - task2
    agent: code_replace_agent



task4:
    description: >
           Esegui comandi da terminale passando al tool sonarscanner il {path_class}.

    expected_output: |
            Se lo scanner è andato a buon fine, senza restituire il codice e gli errori

    agent: sonar_agent



conditional_task5:
     description: |
            Fai code replace di:
            {code_class}
            ovvero il codice iniziale in {path_class},
            perchè, evidentemente, ci sono stati degli errori nel codice refattorizzato da task precedenti. Quindi
            riporta il codice iniziale nel posto giusto.

     expected_output: >
            Se il code replace è andato a buon fine, senza restituire il codice.

     agent: code_replace_agent




conditional_task6:
     description: >
           Hai ricevuto in input una lista di errori SonarScanner provenienti dalla task4.
           **Obiettivo**: restituisci un riassunto chiaro e conciso dei principali problemi rilevati da Sonar
     expected_output: |
           Ritorna JSON con :
           - "valid" : con il valid restituito da task4
           - "errors" : il riassunto degli errori di task4, del tipo:
             - [Tipo di errore]: breve descrizione e suggerimento.
             - [Altro tipo]: ...
           **IMPORTANTE**: il campo `"valid"` nel JSON di output deve corrispondere
           senza alcuna modifica a valid di task4
     context:
       - task4
     agent: riassunto_errori


